#include<iostream>
#include<string.h>
using namespace std;
char s[303];
char now[303];
char dic[505][303];
int n;
int ans;
int main()
{
    scanf("%s",s); 
    cin>>n;
    for(int i=1;i<=n;i++)scanf("%s",dic[i]);
    for(int i=0;i<strlen(s);i++)
    {
        now[i]=s[i];
        for(int j=1;j<=n;j++){
            if(strstr(now,dic[j]))
            {
                ans++;
                memset(now,1,sizeof(now));
            }
        }
    }
    cout<<ans;
    return 0;
}


// 解决这个问题的思路是使用贪心策略，目标是将字符串分割成最多数量的子串，且每个子串都包含字典中的至少一个单词。具体步骤如下：

// 首先，读取输入的原始字符串、字典中单词的数量以及所有字典单词。

// 然后，从字符串的起始位置开始处理，记录当前需要处理的起始位置（初始为0）和分割的数量（初始为0）。

// 接下来，在当前起始位置处，逐步向右扩展子串（即从起始位置开始，依次包含后面的字符），每扩展一个字符，就检查这个子串是否包含字典中的任何一个单词（即判断字典中是否有某个单词是该子串的子串）。

// 一旦找到最短的、包含字典中某个单词的子串，就将分割数量加1，并将当前起始位置更新为这个子串的结束位置的下一个字符，继续处理剩余的字符串部分。

// 如果在处理过程中，从当前起始位置开始无法找到任何包含字典单词的子串，说明整个字符串无法按照要求分割，此时返回0。

// 当整个字符串被完全处理（即当前起始位置到达字符串末尾）时，返回分割的数量，这就是最多的分割数。